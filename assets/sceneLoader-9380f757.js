import{aK as v,a as A,aD as R,m as x,b as L,E,ax as M,O as B,R as O,d as k}from"./local-0dca2fa7.js";import"./main-ba04fe75.js";import"./openPlot-19746b40.js";import"./screenshot-003e2555.js";var F;(function(D){D[D.Clean=0]="Clean",D[D.Stop=1]="Stop",D[D.Sync=2]="Sync",D[D.NoSync=3]="NoSync"})(F||(F={}));class a{static get ForceFullSceneLoadingForIncremental(){return v.ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(t){v.ForceFullSceneLoadingForIncremental=t}static get ShowLoadingScreen(){return v.ShowLoadingScreen}static set ShowLoadingScreen(t){v.ShowLoadingScreen=t}static get loggingLevel(){return v.loggingLevel}static set loggingLevel(t){v.loggingLevel=t}static get CleanBoneMatrixWeights(){return v.CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(t){v.CleanBoneMatrixWeights=t}static GetDefaultPlugin(){return a._RegisteredPlugins[".babylon"]}static _GetPluginForExtension(t){const r=a._RegisteredPlugins[t];return r||(A.Warn("Unable to find a plugin to load "+t+" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes"),a.GetDefaultPlugin())}static _GetPluginForDirectLoad(t){for(const r in a._RegisteredPlugins){const e=a._RegisteredPlugins[r].plugin;if(e.canDirectLoad&&e.canDirectLoad(t))return a._RegisteredPlugins[r]}return a.GetDefaultPlugin()}static _GetPluginForFilename(t){const r=t.indexOf("?");r!==-1&&(t=t.substring(0,r));const e=t.lastIndexOf("."),n=t.substring(e,t.length).toLowerCase();return a._GetPluginForExtension(n)}static _GetDirectLoad(t){return t.substr(0,5)==="data:"?t.substr(5):null}static _FormatErrorMessage(t,r,e){let l="Unable to load from "+(t.rawData?"binary data":t.url);return r?l+=`: ${r}`:e&&(l+=`: ${e}`),l}static _LoadData(t,r,e,n,l,f,g,P){const d=a._GetDirectLoad(t.url);if(t.rawData&&!g)throw"When using ArrayBufferView to load data the file extension must be provided.";const s=g?a._GetPluginForExtension(g):d?a._GetPluginForDirectLoad(t.url):a._GetPluginForFilename(t.url);if(t.rawData&&!s.isBinary)throw"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.";let i;if(s.plugin.createPlugin!==void 0?i=s.plugin.createPlugin():i=s.plugin,!i)throw"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";if(a.OnPluginActivatedObservable.notifyObservers(i),d&&(i.canDirectLoad&&i.canDirectLoad(t.url)||!R(t.url))){if(i.directLoad){const m=i.directLoad(r,d);m.then?m.then(w=>{e(i,w)}).catch(w=>{l("Error in directLoad of _loadData: "+w,w)}):e(i,m)}else e(i,d);return i}const h=s.isBinary,c=(m,w)=>{if(r.isDisposed){l("Scene has been disposed");return}e(i,m,w)};let p=null,u=!1;const o=i.onDisposeObservable;o&&o.add(()=>{u=!0,p&&(p.abort(),p=null),f()});const y=()=>{if(u)return;const m=(w,G)=>{l(w==null?void 0:w.statusText,G)};if(!i.loadFile&&t.rawData)throw"Plugin does not support loading ArrayBufferView.";p=i.loadFile?i.loadFile(r,t.rawData||t.file||t.url,t.rootUrl,c,n,h,m,P):r._loadFile(t.file||t.url,c,n,!0,h,m)},b=r.getEngine();let C=b.enableOfflineSupport;if(C){let m=!1;for(const w of r.disableOfflineSupportExceptionRules)if(w.test(t.url)){m=!0;break}C=!m}return C&&x.OfflineProviderFactory?r.offlineProvider=x.OfflineProviderFactory(t.url,y,b.disableManifestCheck):y(),i}static _GetFileInfo(t,r){let e,n,l=null,f=null;if(!r)e=t,n=L.GetFilename(t),t=L.GetFolderPath(t);else if(r.name){const g=r;e=`file:${g.name}`,n=g.name,l=g}else if(ArrayBuffer.isView(r))e="",n="arrayBuffer",f=r;else if(typeof r=="string"&&r.startsWith("data:"))e=r,n="";else{const g=r;if(g.substr(0,1)==="/")return L.Error("Wrong sceneFilename parameter"),null;e=t+g,n=g}return{url:e,rootUrl:t,name:n,file:l,rawData:f}}static GetPluginForExtension(t){return a._GetPluginForExtension(t).plugin}static IsPluginForExtensionAvailable(t){return!!a._RegisteredPlugins[t]}static RegisterPlugin(t){if(typeof t.extensions=="string"){const r=t.extensions;a._RegisteredPlugins[r.toLowerCase()]={plugin:t,isBinary:!1}}else{const r=t.extensions;Object.keys(r).forEach(e=>{a._RegisteredPlugins[e.toLowerCase()]={plugin:t,isBinary:r[e].isBinary}})}}static ImportMesh(t,r,e="",n=E.LastCreatedScene,l=null,f=null,g=null,P=null,d=""){if(!n)return A.Error("No scene available to import mesh to"),null;const s=a._GetFileInfo(r,e);if(!s)return null;const i={};n.addPendingData(i);const h=()=>{n.removePendingData(i)},c=(o,y)=>{const b=a._FormatErrorMessage(s,o,y);g?g(n,b,new O(b,k.SceneLoaderError,y)):A.Error(b),h()},p=f?o=>{try{f(o)}catch(y){c("Error in onProgress callback: "+y,y)}}:void 0,u=(o,y,b,C,m,w,G)=>{if(n.importedMeshesFiles.push(s.url),l)try{l(o,y,b,C,m,w,G)}catch(N){c("Error in onSuccess callback: "+N,N)}n.removePendingData(i)};return a._LoadData(s,n,(o,y,b)=>{if(o.rewriteRootURL&&(s.rootUrl=o.rewriteRootURL(s.rootUrl,b)),o.importMesh){const C=o,m=new Array,w=new Array,G=new Array;if(!C.importMesh(t,n,y,s.rootUrl,m,w,G,c))return;n.loadingPluginName=o.name,u(m,w,G,[],[],[],[])}else o.importMeshAsync(t,n,y,s.rootUrl,p,s.name).then(m=>{n.loadingPluginName=o.name,u(m.meshes,m.particleSystems,m.skeletons,m.animationGroups,m.transformNodes,m.geometries,m.lights)}).catch(m=>{c(m.message,m)})},p,c,h,P,d)}static ImportMeshAsync(t,r,e="",n=E.LastCreatedScene,l=null,f=null,g=""){return new Promise((P,d)=>{a.ImportMesh(t,r,e,n,(s,i,h,c,p,u,o)=>{P({meshes:s,particleSystems:i,skeletons:h,animationGroups:c,transformNodes:p,geometries:u,lights:o})},l,(s,i,h)=>{d(h||new Error(i))},f,g)})}static Load(t,r="",e=E.LastCreatedEngine,n=null,l=null,f=null,g=null,P=""){return e?a.Append(t,r,new M(e),n,l,f,g,P):(L.Error("No engine available"),null)}static LoadAsync(t,r="",e=E.LastCreatedEngine,n=null,l=null,f=""){return new Promise((g,P)=>{a.Load(t,r,e,d=>{g(d)},n,(d,s,i)=>{P(i||new Error(s))},l,f)})}static Append(t,r="",e=E.LastCreatedScene,n=null,l=null,f=null,g=null,P=""){if(!e)return A.Error("No scene available to append to"),null;const d=a._GetFileInfo(t,r);if(!d)return null;const s={};e.addPendingData(s);const i=()=>{e.removePendingData(s)};a.ShowLoadingScreen&&!this._ShowingLoadingScreen&&(this._ShowingLoadingScreen=!0,e.getEngine().displayLoadingUI(),e.executeWhenReady(()=>{e.getEngine().hideLoadingUI(),this._ShowingLoadingScreen=!1}));const h=(u,o)=>{const y=a._FormatErrorMessage(d,u,o);f?f(e,y,new O(y,k.SceneLoaderError,o)):A.Error(y),i()},c=l?u=>{try{l(u)}catch(o){h("Error in onProgress callback",o)}}:void 0,p=()=>{if(n)try{n(e)}catch(u){h("Error in onSuccess callback",u)}e.removePendingData(s)};return a._LoadData(d,e,(u,o)=>{if(u.load){if(!u.load(e,o,d.rootUrl,h))return;e.loadingPluginName=u.name,p()}else u.loadAsync(e,o,d.rootUrl,c,d.name).then(()=>{e.loadingPluginName=u.name,p()}).catch(b=>{h(b.message,b)})},c,h,i,g,P)}static AppendAsync(t,r="",e=E.LastCreatedScene,n=null,l=null,f=""){return new Promise((g,P)=>{a.Append(t,r,e,d=>{g(d)},n,(d,s,i)=>{P(i||new Error(s))},l,f)})}static LoadAssetContainer(t,r="",e=E.LastCreatedScene,n=null,l=null,f=null,g=null,P=""){if(!e)return A.Error("No scene available to load asset container to"),null;const d=a._GetFileInfo(t,r);if(!d)return null;const s={};e.addPendingData(s);const i=()=>{e.removePendingData(s)},h=(u,o)=>{const y=a._FormatErrorMessage(d,u,o);f?f(e,y,new O(y,k.SceneLoaderError,o)):A.Error(y),i()},c=l?u=>{try{l(u)}catch(o){h("Error in onProgress callback",o)}}:void 0,p=u=>{if(n)try{n(u)}catch(o){h("Error in onSuccess callback",o)}e.removePendingData(s)};return a._LoadData(d,e,(u,o)=>{if(u.loadAssetContainer){const b=u.loadAssetContainer(e,o,d.rootUrl,h);if(!b)return;e.loadingPluginName=u.name,p(b)}else u.loadAssetContainerAsync?u.loadAssetContainerAsync(e,o,d.rootUrl,c,d.name).then(b=>{e.loadingPluginName=u.name,p(b)}).catch(b=>{h(b.message,b)}):h("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.")},c,h,i,g,P)}static LoadAssetContainerAsync(t,r="",e=E.LastCreatedScene,n=null,l=null){return new Promise((f,g)=>{a.LoadAssetContainer(t,r,e,P=>{f(P)},n,(P,d,s)=>{g(s||new Error(d))},l)})}static ImportAnimations(t,r="",e=E.LastCreatedScene,n=!0,l=F.Clean,f=null,g=null,P=null,d=null,s=null){if(!e){A.Error("No scene available to load animations to");return}if(n){for(const p of e.animatables)p.reset();e.stopAllAnimations(),e.animationGroups.slice().forEach(p=>{p.dispose()}),e.getNodes().forEach(p=>{p.animations&&(p.animations=[])})}else switch(l){case F.Clean:e.animationGroups.slice().forEach(c=>{c.dispose()});break;case F.Stop:e.animationGroups.forEach(c=>{c.stop()});break;case F.Sync:e.animationGroups.forEach(c=>{c.reset(),c.restart()});break;case F.NoSync:break;default:A.Error("Unknown animation group loading mode value '"+l+"'");return}const i=e.animatables.length,h=c=>{c.mergeAnimationsTo(e,e.animatables.slice(i),f),c.dispose(),e.onAnimationFileImportedObservable.notifyObservers(e),g&&g(e)};this.LoadAssetContainer(t,r,e,h,P,d,s)}static ImportAnimationsAsync(t,r="",e=E.LastCreatedScene,n=!0,l=F.Clean,f=null,g=null,P=null,d=null,s=null){return new Promise((i,h)=>{a.ImportAnimations(t,r,e,n,l,f,c=>{i(c)},P,(c,p,u)=>{h(u||new Error(p))},s)})}}a.NO_LOGGING=0;a.MINIMAL_LOGGING=1;a.SUMMARY_LOGGING=2;a.DETAILED_LOGGING=3;a.OnPluginActivatedObservable=new B;a._RegisteredPlugins={};a._ShowingLoadingScreen=!1;export{a as SceneLoader,F as SceneLoaderAnimationGroupLoadingMode};
