import{S as F,L as C,I as N,E as k,T as L,a as E,b as x,O as R,R as I,c as O}from"./script-1966d850.js";var D;(function(A){A[A.Clean=0]="Clean",A[A.Stop=1]="Stop",A[A.Sync=2]="Sync",A[A.NoSync=3]="NoSync"})(D||(D={}));class i{static get ForceFullSceneLoadingForIncremental(){return F.ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(e){F.ForceFullSceneLoadingForIncremental=e}static get ShowLoadingScreen(){return F.ShowLoadingScreen}static set ShowLoadingScreen(e){F.ShowLoadingScreen=e}static get loggingLevel(){return F.loggingLevel}static set loggingLevel(e){F.loggingLevel=e}static get CleanBoneMatrixWeights(){return F.CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(e){F.CleanBoneMatrixWeights=e}static GetDefaultPlugin(){return i._RegisteredPlugins[".babylon"]}static _GetPluginForExtension(e){const n=i._RegisteredPlugins[e];return n||(C.Warn("Unable to find a plugin to load "+e+" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes"),i.GetDefaultPlugin())}static _GetPluginForDirectLoad(e){for(const n in i._RegisteredPlugins){const t=i._RegisteredPlugins[n].plugin;if(t.canDirectLoad&&t.canDirectLoad(e))return i._RegisteredPlugins[n]}return i.GetDefaultPlugin()}static _GetPluginForFilename(e){const n=e.indexOf("?");n!==-1&&(e=e.substring(0,n));const t=e.lastIndexOf("."),r=e.substring(t,e.length).toLowerCase();return i._GetPluginForExtension(r)}static _GetDirectLoad(e){return e.substr(0,5)==="data:"?e.substr(5):null}static _FormatErrorMessage(e,n,t){let r="Unable to load from "+e.url;return n?r+=`: ${n}`:t&&(r+=`: ${t}`),r}static _LoadData(e,n,t,r,d,g,P){const o=i._GetDirectLoad(e.url),u=P?i._GetPluginForExtension(P):o?i._GetPluginForDirectLoad(e.url):i._GetPluginForFilename(e.url);let a;if(u.plugin.createPlugin!==void 0?a=u.plugin.createPlugin():a=u.plugin,!a)throw"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";if(i.OnPluginActivatedObservable.notifyObservers(a),o&&(a.canDirectLoad&&a.canDirectLoad(e.url)||!N(e.url))){if(a.directLoad){const f=a.directLoad(n,o);f.then?f.then(b=>{t(a,b)}).catch(b=>{d("Error in directLoad of _loadData: "+b,b)}):t(a,f)}else t(a,o);return a}const m=u.isBinary,p=(f,b)=>{if(n.isDisposed){d("Scene has been disposed");return}t(a,f,b)};let c=null,s=!1;const l=a.onDisposeObservable;l&&l.add(()=>{s=!0,c&&(c.abort(),c=null),g()});const h=()=>{if(s)return;const f=(v,G)=>{d(v==null?void 0:v.statusText,G)},b=e.file||e.url;c=a.loadFile?a.loadFile(n,b,p,r,m,f):n._loadFile(b,p,r,!0,m,f)},y=n.getEngine();let w=y.enableOfflineSupport;if(w){let f=!1;for(const b of n.disableOfflineSupportExceptionRules)if(b.test(e.url)){f=!0;break}w=!f}return w&&k.OfflineProviderFactory?n.offlineProvider=k.OfflineProviderFactory(e.url,h,y.disableManifestCheck):h(),a}static _GetFileInfo(e,n){let t,r,d=null;if(!n)t=e,r=L.GetFilename(e),e=L.GetFolderPath(e);else if(n.name){const g=n;t=`file:${g.name}`,r=g.name,d=g}else if(typeof n=="string"&&n.startsWith("data:"))t=n,r="";else{const g=n;if(g.substr(0,1)==="/")return L.Error("Wrong sceneFilename parameter"),null;t=e+g,r=g}return{url:t,rootUrl:e,name:r,file:d}}static GetPluginForExtension(e){return i._GetPluginForExtension(e).plugin}static IsPluginForExtensionAvailable(e){return!!i._RegisteredPlugins[e]}static RegisterPlugin(e){if(typeof e.extensions=="string"){const n=e.extensions;i._RegisteredPlugins[n.toLowerCase()]={plugin:e,isBinary:!1}}else{const n=e.extensions;Object.keys(n).forEach(t=>{i._RegisteredPlugins[t.toLowerCase()]={plugin:e,isBinary:n[t].isBinary}})}}static ImportMesh(e,n,t="",r=E.LastCreatedScene,d=null,g=null,P=null,o=null){if(!r)return C.Error("No scene available to import mesh to"),null;const u=i._GetFileInfo(n,t);if(!u)return null;const a={};r.addPendingData(a);const m=()=>{r.removePendingData(a)},p=(l,h)=>{const y=i._FormatErrorMessage(u,l,h);P?P(r,y,new I(y,O.SceneLoaderError,h)):C.Error(y),m()},c=g?l=>{try{g(l)}catch(h){p("Error in onProgress callback: "+h,h)}}:void 0,s=(l,h,y,w,f,b,v)=>{if(r.importedMeshesFiles.push(u.url),d)try{d(l,h,y,w,f,b,v)}catch(G){p("Error in onSuccess callback: "+G,G)}r.removePendingData(a)};return i._LoadData(u,r,(l,h,y)=>{if(l.rewriteRootURL&&(u.rootUrl=l.rewriteRootURL(u.rootUrl,y)),l.importMesh){const w=l,f=new Array,b=new Array,v=new Array;if(!w.importMesh(e,r,h,u.rootUrl,f,b,v,p))return;r.loadingPluginName=l.name,s(f,b,v,[],[],[],[])}else l.importMeshAsync(e,r,h,u.rootUrl,c,u.name).then(f=>{r.loadingPluginName=l.name,s(f.meshes,f.particleSystems,f.skeletons,f.animationGroups,f.transformNodes,f.geometries,f.lights)}).catch(f=>{p(f.message,f)})},c,p,m,o)}static ImportMeshAsync(e,n,t="",r=E.LastCreatedScene,d=null,g=null){return new Promise((P,o)=>{i.ImportMesh(e,n,t,r,(u,a,m,p,c,s,l)=>{P({meshes:u,particleSystems:a,skeletons:m,animationGroups:p,transformNodes:c,geometries:s,lights:l})},d,(u,a,m)=>{o(m||new Error(a))},g)})}static Load(e,n="",t=E.LastCreatedEngine,r=null,d=null,g=null,P=null){return t?i.Append(e,n,new x(t),r,d,g,P):(L.Error("No engine available"),null)}static LoadAsync(e,n="",t=E.LastCreatedEngine,r=null,d=null){return new Promise((g,P)=>{i.Load(e,n,t,o=>{g(o)},r,(o,u,a)=>{P(a||new Error(u))},d)})}static Append(e,n="",t=E.LastCreatedScene,r=null,d=null,g=null,P=null){if(!t)return C.Error("No scene available to append to"),null;const o=i._GetFileInfo(e,n);if(!o)return null;const u={};t.addPendingData(u);const a=()=>{t.removePendingData(u)};i.ShowLoadingScreen&&!this._ShowingLoadingScreen&&(this._ShowingLoadingScreen=!0,t.getEngine().displayLoadingUI(),t.executeWhenReady(()=>{t.getEngine().hideLoadingUI(),this._ShowingLoadingScreen=!1}));const m=(s,l)=>{const h=i._FormatErrorMessage(o,s,l);g?g(t,h,new I(h,O.SceneLoaderError,l)):C.Error(h),a()},p=d?s=>{try{d(s)}catch(l){m("Error in onProgress callback",l)}}:void 0,c=()=>{if(r)try{r(t)}catch(s){m("Error in onSuccess callback",s)}t.removePendingData(u)};return i._LoadData(o,t,(s,l)=>{if(s.load){if(!s.load(t,l,o.rootUrl,m))return;t.loadingPluginName=s.name,c()}else s.loadAsync(t,l,o.rootUrl,p,o.name).then(()=>{t.loadingPluginName=s.name,c()}).catch(y=>{m(y.message,y)})},p,m,a,P)}static AppendAsync(e,n="",t=E.LastCreatedScene,r=null,d=null){return new Promise((g,P)=>{i.Append(e,n,t,o=>{g(o)},r,(o,u,a)=>{P(a||new Error(u))},d)})}static LoadAssetContainer(e,n="",t=E.LastCreatedScene,r=null,d=null,g=null,P=null){if(!t)return C.Error("No scene available to load asset container to"),null;const o=i._GetFileInfo(e,n);if(!o)return null;const u={};t.addPendingData(u);const a=()=>{t.removePendingData(u)},m=(s,l)=>{const h=i._FormatErrorMessage(o,s,l);g?g(t,h,new I(h,O.SceneLoaderError,l)):C.Error(h),a()},p=d?s=>{try{d(s)}catch(l){m("Error in onProgress callback",l)}}:void 0,c=s=>{if(r)try{r(s)}catch(l){m("Error in onSuccess callback",l)}t.removePendingData(u)};return i._LoadData(o,t,(s,l)=>{if(s.loadAssetContainer){const y=s.loadAssetContainer(t,l,o.rootUrl,m);if(!y)return;t.loadingPluginName=s.name,c(y)}else s.loadAssetContainerAsync?s.loadAssetContainerAsync(t,l,o.rootUrl,p,o.name).then(y=>{t.loadingPluginName=s.name,c(y)}).catch(y=>{m(y.message,y)}):m("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.")},p,m,a,P)}static LoadAssetContainerAsync(e,n="",t=E.LastCreatedScene,r=null,d=null){return new Promise((g,P)=>{i.LoadAssetContainer(e,n,t,o=>{g(o)},r,(o,u,a)=>{P(a||new Error(u))},d)})}static ImportAnimations(e,n="",t=E.LastCreatedScene,r=!0,d=D.Clean,g=null,P=null,o=null,u=null,a=null){if(!t){C.Error("No scene available to load animations to");return}if(r){for(const s of t.animatables)s.reset();t.stopAllAnimations(),t.animationGroups.slice().forEach(s=>{s.dispose()}),t.getNodes().forEach(s=>{s.animations&&(s.animations=[])})}else switch(d){case D.Clean:t.animationGroups.slice().forEach(c=>{c.dispose()});break;case D.Stop:t.animationGroups.forEach(c=>{c.stop()});break;case D.Sync:t.animationGroups.forEach(c=>{c.reset(),c.restart()});break;case D.NoSync:break;default:C.Error("Unknown animation group loading mode value '"+d+"'");return}const m=t.animatables.length,p=c=>{c.mergeAnimationsTo(t,t.animatables.slice(m),g),c.dispose(),t.onAnimationFileImportedObservable.notifyObservers(t),P&&P(t)};this.LoadAssetContainer(e,n,t,p,o,u,a)}static ImportAnimationsAsync(e,n="",t=E.LastCreatedScene,r=!0,d=D.Clean,g=null,P=null,o=null,u=null,a=null){return new Promise((m,p)=>{i.ImportAnimations(e,n,t,r,d,g,c=>{m(c)},o,(c,s,l)=>{p(l||new Error(s))},a)})}}i.NO_LOGGING=0;i.MINIMAL_LOGGING=1;i.SUMMARY_LOGGING=2;i.DETAILED_LOGGING=3;i.OnPluginActivatedObservable=new R;i._RegisteredPlugins={};i._ShowingLoadingScreen=!1;export{i as SceneLoader,D as SceneLoaderAnimationGroupLoadingMode};
