import{S as F,L as C,I as N,E as k,T as L,a as E,b as x,O as R,R as I,c as O}from"./local.82c0fe45.js";import"./main.a67af416.js";import"./openPlot.bc4834b4.js";import"./screenshot.92b47fb5.js";var D;(function(A){A[A.Clean=0]="Clean",A[A.Stop=1]="Stop",A[A.Sync=2]="Sync",A[A.NoSync=3]="NoSync"})(D||(D={}));class s{static get ForceFullSceneLoadingForIncremental(){return F.ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(e){F.ForceFullSceneLoadingForIncremental=e}static get ShowLoadingScreen(){return F.ShowLoadingScreen}static set ShowLoadingScreen(e){F.ShowLoadingScreen=e}static get loggingLevel(){return F.loggingLevel}static set loggingLevel(e){F.loggingLevel=e}static get CleanBoneMatrixWeights(){return F.CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(e){F.CleanBoneMatrixWeights=e}static GetDefaultPlugin(){return s._RegisteredPlugins[".babylon"]}static _GetPluginForExtension(e){const n=s._RegisteredPlugins[e];return n||(C.Warn("Unable to find a plugin to load "+e+" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes"),s.GetDefaultPlugin())}static _GetPluginForDirectLoad(e){for(const n in s._RegisteredPlugins){const t=s._RegisteredPlugins[n].plugin;if(t.canDirectLoad&&t.canDirectLoad(e))return s._RegisteredPlugins[n]}return s.GetDefaultPlugin()}static _GetPluginForFilename(e){const n=e.indexOf("?");n!==-1&&(e=e.substring(0,n));const t=e.lastIndexOf("."),r=e.substring(t,e.length).toLowerCase();return s._GetPluginForExtension(r)}static _GetDirectLoad(e){return e.substr(0,5)==="data:"?e.substr(5):null}static _FormatErrorMessage(e,n,t){let r="Unable to load from "+e.url;return n?r+=`: ${n}`:t&&(r+=`: ${t}`),r}static _LoadData(e,n,t,r,d,g,P){const l=s._GetDirectLoad(e.url),u=P?s._GetPluginForExtension(P):l?s._GetPluginForDirectLoad(e.url):s._GetPluginForFilename(e.url);let a;if(u.plugin.createPlugin!==void 0?a=u.plugin.createPlugin():a=u.plugin,!a)throw"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";if(s.OnPluginActivatedObservable.notifyObservers(a),l&&(a.canDirectLoad&&a.canDirectLoad(e.url)||!N(e.url))){if(a.directLoad){const f=a.directLoad(n,l);f.then?f.then(b=>{t(a,b)}).catch(b=>{d("Error in directLoad of _loadData: "+b,b)}):t(a,f)}else t(a,l);return a}const m=u.isBinary,y=(f,b)=>{if(n.isDisposed){d("Scene has been disposed");return}t(a,f,b)};let c=null,i=!1;const o=a.onDisposeObservable;o&&o.add(()=>{i=!0,c&&(c.abort(),c=null),g()});const h=()=>{if(i)return;const f=(v,G)=>{d(v==null?void 0:v.statusText,G)},b=e.file||e.url;c=a.loadFile?a.loadFile(n,b,y,r,m,f):n._loadFile(b,y,r,!0,m,f)},p=n.getEngine();let w=p.enableOfflineSupport;if(w){let f=!1;for(const b of n.disableOfflineSupportExceptionRules)if(b.test(e.url)){f=!0;break}w=!f}return w&&k.OfflineProviderFactory?n.offlineProvider=k.OfflineProviderFactory(e.url,h,p.disableManifestCheck):h(),a}static _GetFileInfo(e,n){let t,r,d=null;if(!n)t=e,r=L.GetFilename(e),e=L.GetFolderPath(e);else if(n.name){const g=n;t=`file:${g.name}`,r=g.name,d=g}else if(typeof n=="string"&&n.startsWith("data:"))t=n,r="";else{const g=n;if(g.substr(0,1)==="/")return L.Error("Wrong sceneFilename parameter"),null;t=e+g,r=g}return{url:t,rootUrl:e,name:r,file:d}}static GetPluginForExtension(e){return s._GetPluginForExtension(e).plugin}static IsPluginForExtensionAvailable(e){return!!s._RegisteredPlugins[e]}static RegisterPlugin(e){if(typeof e.extensions=="string"){const n=e.extensions;s._RegisteredPlugins[n.toLowerCase()]={plugin:e,isBinary:!1}}else{const n=e.extensions;Object.keys(n).forEach(t=>{s._RegisteredPlugins[t.toLowerCase()]={plugin:e,isBinary:n[t].isBinary}})}}static ImportMesh(e,n,t="",r=E.LastCreatedScene,d=null,g=null,P=null,l=null){if(!r)return C.Error("No scene available to import mesh to"),null;const u=s._GetFileInfo(n,t);if(!u)return null;const a={};r.addPendingData(a);const m=()=>{r.removePendingData(a)},y=(o,h)=>{const p=s._FormatErrorMessage(u,o,h);P?P(r,p,new I(p,O.SceneLoaderError,h)):C.Error(p),m()},c=g?o=>{try{g(o)}catch(h){y("Error in onProgress callback: "+h,h)}}:void 0,i=(o,h,p,w,f,b,v)=>{if(r.importedMeshesFiles.push(u.url),d)try{d(o,h,p,w,f,b,v)}catch(G){y("Error in onSuccess callback: "+G,G)}r.removePendingData(a)};return s._LoadData(u,r,(o,h,p)=>{if(o.rewriteRootURL&&(u.rootUrl=o.rewriteRootURL(u.rootUrl,p)),o.importMesh){const w=o,f=new Array,b=new Array,v=new Array;if(!w.importMesh(e,r,h,u.rootUrl,f,b,v,y))return;r.loadingPluginName=o.name,i(f,b,v,[],[],[],[])}else o.importMeshAsync(e,r,h,u.rootUrl,c,u.name).then(f=>{r.loadingPluginName=o.name,i(f.meshes,f.particleSystems,f.skeletons,f.animationGroups,f.transformNodes,f.geometries,f.lights)}).catch(f=>{y(f.message,f)})},c,y,m,l)}static ImportMeshAsync(e,n,t="",r=E.LastCreatedScene,d=null,g=null){return new Promise((P,l)=>{s.ImportMesh(e,n,t,r,(u,a,m,y,c,i,o)=>{P({meshes:u,particleSystems:a,skeletons:m,animationGroups:y,transformNodes:c,geometries:i,lights:o})},d,(u,a,m)=>{l(m||new Error(a))},g)})}static Load(e,n="",t=E.LastCreatedEngine,r=null,d=null,g=null,P=null){return t?s.Append(e,n,new x(t),r,d,g,P):(L.Error("No engine available"),null)}static LoadAsync(e,n="",t=E.LastCreatedEngine,r=null,d=null){return new Promise((g,P)=>{s.Load(e,n,t,l=>{g(l)},r,(l,u,a)=>{P(a||new Error(u))},d)})}static Append(e,n="",t=E.LastCreatedScene,r=null,d=null,g=null,P=null){if(!t)return C.Error("No scene available to append to"),null;const l=s._GetFileInfo(e,n);if(!l)return null;const u={};t.addPendingData(u);const a=()=>{t.removePendingData(u)};s.ShowLoadingScreen&&!this._ShowingLoadingScreen&&(this._ShowingLoadingScreen=!0,t.getEngine().displayLoadingUI(),t.executeWhenReady(()=>{t.getEngine().hideLoadingUI(),this._ShowingLoadingScreen=!1}));const m=(i,o)=>{const h=s._FormatErrorMessage(l,i,o);g?g(t,h,new I(h,O.SceneLoaderError,o)):C.Error(h),a()},y=d?i=>{try{d(i)}catch(o){m("Error in onProgress callback",o)}}:void 0,c=()=>{if(r)try{r(t)}catch(i){m("Error in onSuccess callback",i)}t.removePendingData(u)};return s._LoadData(l,t,(i,o)=>{if(i.load){if(!i.load(t,o,l.rootUrl,m))return;t.loadingPluginName=i.name,c()}else i.loadAsync(t,o,l.rootUrl,y,l.name).then(()=>{t.loadingPluginName=i.name,c()}).catch(p=>{m(p.message,p)})},y,m,a,P)}static AppendAsync(e,n="",t=E.LastCreatedScene,r=null,d=null){return new Promise((g,P)=>{s.Append(e,n,t,l=>{g(l)},r,(l,u,a)=>{P(a||new Error(u))},d)})}static LoadAssetContainer(e,n="",t=E.LastCreatedScene,r=null,d=null,g=null,P=null){if(!t)return C.Error("No scene available to load asset container to"),null;const l=s._GetFileInfo(e,n);if(!l)return null;const u={};t.addPendingData(u);const a=()=>{t.removePendingData(u)},m=(i,o)=>{const h=s._FormatErrorMessage(l,i,o);g?g(t,h,new I(h,O.SceneLoaderError,o)):C.Error(h),a()},y=d?i=>{try{d(i)}catch(o){m("Error in onProgress callback",o)}}:void 0,c=i=>{if(r)try{r(i)}catch(o){m("Error in onSuccess callback",o)}t.removePendingData(u)};return s._LoadData(l,t,(i,o)=>{if(i.loadAssetContainer){const p=i.loadAssetContainer(t,o,l.rootUrl,m);if(!p)return;t.loadingPluginName=i.name,c(p)}else i.loadAssetContainerAsync?i.loadAssetContainerAsync(t,o,l.rootUrl,y,l.name).then(p=>{t.loadingPluginName=i.name,c(p)}).catch(p=>{m(p.message,p)}):m("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.")},y,m,a,P)}static LoadAssetContainerAsync(e,n="",t=E.LastCreatedScene,r=null,d=null){return new Promise((g,P)=>{s.LoadAssetContainer(e,n,t,l=>{g(l)},r,(l,u,a)=>{P(a||new Error(u))},d)})}static ImportAnimations(e,n="",t=E.LastCreatedScene,r=!0,d=D.Clean,g=null,P=null,l=null,u=null,a=null){if(!t){C.Error("No scene available to load animations to");return}if(r){for(const i of t.animatables)i.reset();t.stopAllAnimations(),t.animationGroups.slice().forEach(i=>{i.dispose()}),t.getNodes().forEach(i=>{i.animations&&(i.animations=[])})}else switch(d){case D.Clean:t.animationGroups.slice().forEach(c=>{c.dispose()});break;case D.Stop:t.animationGroups.forEach(c=>{c.stop()});break;case D.Sync:t.animationGroups.forEach(c=>{c.reset(),c.restart()});break;case D.NoSync:break;default:C.Error("Unknown animation group loading mode value '"+d+"'");return}const m=t.animatables.length,y=c=>{c.mergeAnimationsTo(t,t.animatables.slice(m),g),c.dispose(),t.onAnimationFileImportedObservable.notifyObservers(t),P&&P(t)};this.LoadAssetContainer(e,n,t,y,l,u,a)}static ImportAnimationsAsync(e,n="",t=E.LastCreatedScene,r=!0,d=D.Clean,g=null,P=null,l=null,u=null,a=null){return new Promise((m,y)=>{s.ImportAnimations(e,n,t,r,d,g,c=>{m(c)},l,(c,i,o)=>{y(o||new Error(i))},a)})}}s.NO_LOGGING=0;s.MINIMAL_LOGGING=1;s.SUMMARY_LOGGING=2;s.DETAILED_LOGGING=3;s.OnPluginActivatedObservable=new R;s._RegisteredPlugins={};s._ShowingLoadingScreen=!1;export{s as SceneLoader,D as SceneLoaderAnimationGroupLoadingMode};
